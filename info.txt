java垃圾回收算法
   1.标记-清除算法，将某个区域所有要回收的内存标记，然后清除（内存碎片严重，老年代算法）
   2.标记-整理算法，将某块区域所有要回收的内存移动至某一端，然后全部清除，老年代算法
   3.标记-复制算法，将区域分为两块，只有一块放内存，将有内存的这部分的存活对象全部转移至另一个区域，然后将原区域全部清除，年轻代算法


jdk1.8垃圾回收器
    年轻代Parallel Scavenge，老年代Parallel Old
synchronized原理
   偏向锁  
   轻量级锁
   重量级锁
zk和eureka作为注册中心的不同点?DUBBO实现的是CP？
   没用过这两个注册中心，dubbo实现的是cp是啥意思？dubbo的mock机制应该可以保证cp和ap，是否取决于用什么，服务降级可以保证ap，
   集群容错里的Forking Cluster可以在一定程度上确保cp

怎么确保mq中消息的有序性
    发送消息时，生产者让所有消息发到一个队列中，例如rocketmq中 rocketMQTemplate.syncSendOrderly(String destination, Message<?> message, String hashKey)中，同时消费这些队列的消费者在消费时将这些队列锁上，互斥消费
怎么确保mq中消息不丢失
    生产者端
           1.同步发送并接受检验结果，对发送失败的消息进行再重试，为了规避部分broker宕机导致的发送失败，可以开启故障规避策略
           2.事务消息，可以有效解决broker落盘消息成功但给生产者ack时失败的情况，后续回查确保一定发出
    broker
         同步刷盘
    主从同步阶段
         Dledger机制
    消费者端
         消息重试16次、死信队列（顺序消息基本可以认为无限重试，需要做好异常处理）
    
spring的aop原理

    通过cglib代理实现，将要实现的切面作为拦截器链放入被代理对象，方法执行过程中依次调用链中的实现。正常情况在bean后处理阶段代理，循环依赖情况下，a依赖b,b依赖a的情况下a的代理通过三级缓存实现，b照旧

spring中bean的循环依赖怎么解决

    利用二级缓存实现，在a依赖b,b依赖a的情况下，a实例化，在三级缓存中加入相关的工厂方法后进行DI操作，发现a依赖b，尝试获取b失败并开始创建b，
    b实例化后也在三级缓存中加入相关的工厂方法接下来进行DI操作，发现b依赖a，尝试获取a，从三级缓存中的工厂方法生成早期bean，并放入二级缓存，
    并依赖该二级缓存完成后续DI步骤，依赖注入解决
    三级缓存的作用：仅在循环依赖过程中循环依赖的双方被aop代理时，负责在工厂方法中实现代理逻辑
  （三级缓存中的工厂方法本质是调用SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference(Object bean, String beanName) 
    除了aop实现的子类外，其他都是直接返回了个bean，没做任何处理）
    这里三级缓存的作用可能更大程度上是代码规范

java里的锁有哪些
   juc lock，synchronized，cas，分布式锁（锁多个服务实例共享的资源）
乐观锁和悲观锁
  juc lock，synchronized 悲观锁 ，认为每次加锁过程中一定有锁冲突，先锁上标志位
  cas  乐观锁   认为每次加锁过程中没有锁冲突，修改时先确定传入的预期值是否时当前的真实值，是则修改，否则自旋重试再修改
代码死锁怎么处理
  jstack pid找到死锁的地方，修改代码，重启？？？

java内存模型
内存溢出怎么排查
sentinel的限流算法是咋样的
没用过
sentinel的根据多参数限流怎么配置
没用过
java类加载
什么是双亲委派，以及为什么要双亲委派
加载器加载一个类时，首先会去递归查看自己父类加载器是否加载该类，如果bootstrap类加载器也没有加载过，则委托给当前类加载器进行加载，主要为了避免app classLoader瞎几把加载String，Object等类导致程序异常
java的线程池有哪些，简单说下用法
线程池有哪几种？线程池的参数怎么设置的？

newFixedThreadPool
newSingleThreadExecutor
newSingleThreadScheduledExecutor
newScheduledThreadPool

ThreadLocal简单讲讲
线程本地变量，ThreadLocal有一个内部类ThreadLocalMap，这个ThreadLocalMap本质是ThreadLocalMap的内部类Entry的数组，Entry包含两个参数referent和value，referent指向当前threadLocal自己（弱引用），value指向线程本地变量
线程Thread中有一个变量threadLocals会保存所有在该线程执行过程中调用过ThreadLocal.set()的ThreadLocal变量和线程本地变量，当entry中的某个referent不存在外部强引用时，下次gc时会被回收掉，referent被置为null，但value仍然没有清除，仍然有内存泄漏风险
此时，当调用threadLocal.set()和get()时，会尝试清除当前thread.threadLocals中referent为null的项，勉强避免内存泄漏，所以最好的方法是用完调用threadLocal.remove()

索引的类型

主键索引，唯一索引，普通索引，组合索引

聚簇索引跟非聚簇索引的区别

mysql innodb中主键索引就是聚簇索引（如果没有主键，会用第一个唯一索引构建聚簇索引，如果没有唯一索引，会隐式地按自己规则构建一个聚簇索引，即innodb每个表有且只有一个聚簇索引）
非聚簇索引就是非主键索引（唯一，普通，组合）构成的索引
主键索引和非主键索引区别主要在
1.非聚簇索引的叶子节点每条数据是pk和该索引字段的值，聚簇索引的叶子节点的每条数据则是完整的一行数据
2.后果就是当根据非主键字段查询时，如果要返回的字段不包含当前索引命中的字段，则在扫描了该非聚簇索引获得该行数据的pk后还要回聚簇索引查到完整的数据

缓存穿透、击穿。其它缓存的中间件有什么？区别在于？

缓存穿透：查询的数据即不在缓存里也不在数据库里，导致同时大量查询某数据导致数据库被打崩
解决方法：
        1.布隆过滤器
        2.缓存短过期时间的空值
        3.网关层过滤某些明显异常的值或者限流

缓存击穿：查询的数据不在缓存里但在数据库里，某时刻缓存失效同时针对该数据的查询大规模请求到服务器，由于没有缓存，大量请求打到数据库
解决方法：
       1.juc lock 或者分布式锁（其他没抢到数据的服务是sleep后继续抢锁直到获取到锁返回缓存值还是直接返回空数据，让屌毛客户们继续刷呢）
       2.热点数据永不过期

缓存击穿：查询的数据不在缓存里但在数据库里，且由于过期时间一样导致缓存大面积失效，此时大量请求导致到服务器导致的大量请求打到数据库
解决方法：
       1.juc lock 或者分布式锁
       2.缓存时间在原有的时间基础上再加点随机数让失效时间分散一下
       3.能永不过期的尽量永不过期

其他缓存中间件没太了解过，听说过memecached，caffeine

Redis的高可用性方案

Redis的缓存过期策略

定时删除
含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除
优点：保证内存被尽快释放
缺点：
若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key
定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重
惰性删除
含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。
优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）
缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）
定期删除
含义：每隔一段时间执行一次删除(在redis.conf配置文件设置hz，1s刷新的频率)过期key操作
优点：
通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理"定时删除"的缺点
定期删除过期key--处理"惰性删除"的缺点
缺点
在内存友好方面，不如"定时删除"
在CPU时间友好方面，不如"惰性删除"
难点
合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）

Redis的持久化机制

    RDB
        保存的是某一时刻redis内存中所有的数据的快照
    优点
        1.RDB文件小，加载快
        2.Redis加载RDB文件的速度比AOF快很多，因为RDB文件中直接存储的时内存数据，而AOF文件中存储的是一条条命令，需要重演命令。
    缺点
        1.RDB无法做到实时持久化，若在两次bgsave间宕机，则会丢失分钟级的增量数据，不适用于实时性要求较高的场景
        2.RDB的cow机制中，fork子进程属于重量级操作，并且会阻塞redis主进程（虽然只是fork动作的时候阻塞）
        3.存在老版本的Redis不兼容新版本RDB格式文件的问题
    触发时机
        1.手动调用save，bgsave 
        2.满足redis.conf中的'save'配置项内容
        3.执行shutdown命令关闭服务器时，如果没有开启AOF持久化功能，那么会自动执行一次bgsave
        4.主从全量复制时，主机向所有从机发送rdb文件

    AOF
        会将每次的写操作追加进aof文件中，并定时优化该aof文件，覆盖部分写操作，减少文件大小（重启时默认使用aof机制）
    优点  
        AOF只是追加写日志文件，对服务器性能影响较小，速度比RDB要快，消耗的内存较少
        实时性比RDB好，默认1s写一次，如果发送数据丢失，可能就丢1s的
    缺点
        文件体积较大，且需要随时覆盖部分写操作
        AOF重演命令式的恢复数据，速度显然比RDB要慢。
    触发时机
         开启redis.conf中的'appendonly yes  '配置项内容，默认1s1次（appendfsync everysec）

    Redis 4.0 之后的混合持久化
         开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入aof文件，然后在将aof_rewrite_buf重写缓冲区的增量命令以AOF方式写入到文件，
         写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。
         简单地说：新的AOF文件前半段是RDB格式的全量数据后半段是AOF格式的增量数据

缓存db数据一致性
      笨比方法：延时双删，延时是为了尽可能避免一些查询超耗时的请求读到了脏数据，但也无法百分百避免
      最终一致性方法：
            1.将相关请求丢到队列里处理
            2.监听数据库内容变化的文件（例如mysql的binlog或者mongodb的oplog）,实时修改缓存

数据库的隔离级别？不可重复读和幻读区别是什么？除了全表加锁以外，怎么解决幻读？

读未提交，读已提交，可重复读，串行化

不可重复读针对数据修改，幻读针对数据新增
不可重复读例子：
      在读已提交事务隔离级别下，事务a首先读取了一批数据，此时，另一个事务b修改了这批数据的某一个数据并提交，然后事务a又使用同样的sql语句读取数据，发现数据被改了，哦豁
幻读例子
      在可重复读事务隔离级别下，事务a首先读取了一批数据，此时，另一个事务b新增了一条数据并提交（假设该新增数据id为114514，且事务a刚刚执行的sql语法上能覆盖该记录），此时事务a执行update db set a='777' where id = 114514
      会发现该update操作执行成功（affected rows:1）,同时再调用初始的sql查询语句时id为114514的数据也被查到了，哦豁

MYSQL索引的数据结构是什么？B树和B+树区别是什么？MYSQL中查询一条数据，分几次查询？

b+树是b树的扩展，主要区别是
1.b树的每个节点都会存储真实的数据，b+树的每个节点的数据只包含当前数据的pk和指向下个节点的指针
2.b+树的叶子节点才包含完整的数据，且数据间是一个双向链表，方便范围查询
3.b+树的深度可能基本就在3左右（千万级别数据），b树不一定

什么叫分几次查询？
      走聚簇索引和非聚簇索引的情况？
      1.查询字段没有索引，全表查询，1次
      2.查询字段部分被非主键索引命中，先查非聚簇索引查到主键，再根据主键去聚簇索引按非索引字段过滤，2次
      3.查询字段部分被主键索引命中，去聚簇索引根据主键查到后再按非索引字段过滤，1次
      4.查询字段完全被非主键索引命中
          4.1要返回的字段不全在查询字段里，先查非聚簇索引，再查聚簇索引 2次
          4.2要返回的字段全在查询字段里，只查非聚簇索引，1次
      5.查询字段完全被主键索引命中，只查聚簇索引，1次

mysql innodb特点和原理

mysql性能优化

分库分表的策略
没做过
LB的策略除了轮询还有什么？

随机，最近机房原则，按消费者均分

Concurrent HashMap的原理和实现机制。

table[]+node，通过synchronized和cas控制并发

配置中心用的是什么？不同配置中心区别在于？
配置和服务中心都是nacos，其他没用过，具体区别应该也就是些主从同步的逻辑吧

线程并发有哪些工具
信号量（屌单词不会拼），countdownlatch，barrier


频繁younggc怎么办
1.本身年轻代分配的小，或者本身服务就会产生大量死得快的对象，加空间就是了
2.代码问题，例如哪没写好导致的内存泄漏


微服务架构理解，优缺点
优点
    1.解耦
    2.方便部署
    3.容错能力更强
缺点
    1.系统变复杂了
    2.服务间通信
   
springcloud 常用注解

@RefreshScope
主要用在类和方法上，用于当该类或者该方法中的数据在注册中心被修改后的动态刷新